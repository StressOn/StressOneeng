<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Production Monitoring Dashboard</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    
    <!-- Firebase & Chart.js -->
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-auth.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.17.0/xlsx.full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@1.0.0"></script>

    <style>
        /* [Keep ALL your existing CSS styles exactly as they are] */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Arial', sans-serif;
            background-color: #f5f5f5;
            color: #333;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }
        .container {
            max-width: 1400px;
            margin: 80px auto 60px auto;
            padding: 30px;
            flex-grow: 1;
        }
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background-color: #007BFF;
            color: white;
            font-size: 2.2rem;
            text-align: center;
            padding: 25px 0;
            z-index: 1000;
        }
        .section {
            background-color: white;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.1);
            border-radius: 10px;
        }
        .section h2 {
            font-size: 2rem;
            color: #007BFF;
            margin-bottom: 15px;
        }
        .grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 30px;
        }
        .info-box {
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            transition: transform 0.2s;
            color: white;
            font-weight: bold;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        .info-box:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
        }
        .info-box:nth-child(1) {
            background: linear-gradient(135deg, #4e54c8, #8f94fb);
            border-left: 5px solid #3a3f9e;
        }
        .info-box:nth-child(2) {
            background: linear-gradient(135deg, #11998e, #38ef7d);
            border-left: 5px solid #0a6e5d;
        }
        .info-box:nth-child(3) {
            background: linear-gradient(135deg, #f46b45, #eea849);
            border-left: 5px solid #d35400;
        }
        .info-box:nth-child(4) {
            background: linear-gradient(135deg, #00c6ff, #0072ff);
            border-left: 5px solid #0062cc;
        }
        .info-box:nth-child(5) {
            background: linear-gradient(135deg, #ff416c, #ff4b2b);
            border-left: 5px solid #c0392b;
        }
        .info-box:nth-child(6) {
            background: linear-gradient(135deg, #556270, #4ecdc4);
            border-left: 5px solid #2c3e50;
        }
        .info-box:nth-child(7) {
            background: linear-gradient(135deg, #8e2de2, #4a00e0);
            border-left: 5px solid #6a1b9a;
        }
        .Running { color: #2ecc71; }
        .Stopped { color: #e74c3c; }
        .Offline { color: #f39c12; }
        .chart-container {
            width: 100%;
            height: 500px;
            position: relative;
            background-color: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.1);
            margin-top: 30px;
            border: 2px solid #007BFF;
        }
        .export-button {
            background-color: #007BFF;
            color: white;
            padding: 15px 30px;
            border: none;
            cursor: pointer;
            border-radius: 5px;
            font-size: 1.2rem;
        }
        .export-button:hover {
            background-color: #0056b3;
        }
        footer {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 20px 0;
            text-align: center;
            background-color: #333;
            color: white;
            z-index: 1000;
        }
        @media only screen and (max-width: 768px) {
            .header {
                font-size: 1.5rem;
                padding: 10px 0;
            }
            .container {
                width: 95%;
                margin-top: 60px;
                margin-bottom: 50px;
                padding: 10px;
            }
            .section h2 {
                font-size: 1.2rem;
            }
            .grid {
                grid-template-columns: 1fr;
                gap: 10px;
            }
            .chart-container {
                height: 300px;
            }
            .info-box {
                font-size: 0.9rem;
                padding: 10px;
            }
            .export-button {
                width: 100%;
                font-size: 0.9rem;
            }
            footer {
                font-size: 0.8rem;
                padding: 10px 0;
            }
        }
        #machineStatus {
            font-weight: bold;
        }
        .loading {
            opacity: 0.7;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div class="header">
        Production Monitoring Dashboard
    </div>

    <div class="container">
        <button class="export-button" onclick="goBack()">Back to Page</button>
        <div class="section">
            <h2>Production Summary</h2>
            <div class="grid">
                <div class="info-box">
                    <strong>Finished Length</strong>
                    <div id="lastValueDisplay">Loading...</div>
                </div>
                <div class="info-box">
                    <strong>Last Update</strong>
                    <div id="lastUpdateDisplay">Loading...</div>
                </div>
                <div class="info-box">
                    <strong>Reset Production</strong>
                    <div id="last24HourProduction">Loading...</div>
                </div>
                <div class="info-box">
                    <strong>Yesterday Production</strong>
                    <div id="perDayProduction">Loading...</div>
                </div>
                <div class="info-box">
                    <strong>Month Production</strong>
                    <div id="perMonthProduction">Loading...</div>
                </div>
                <div class="info-box">
                    <strong>Machine Status</strong>
                    <div id="machineStatus">Loading...</div>
                </div>
                <div class="info-box">
                    <strong>Machine Speed</strong>
                    <div id="machineSpeed">Loading...</div>
                </div>
            </div>
        </div>

        <div class="section">
            <h2>Production Over Time</h2>
            <div class="chart-container">
                <canvas id="productionChart"></canvas>
            </div>
        </div>

        <div class="section">
            <button class="export-button" onclick="exportToExcel()">Export Production Data to Excel</button>
        </div>
    </div>

    <footer>
        Systematic Industries Ltd | Production Monitoring System Â© 2025
    </footer>

    <script>
        // Performance Optimizations
        const OPTIMIZATION_CONFIG = {
            CHART_DATA_POINTS: 100, // Limit chart points for better performance
            FIREBASE_LIMIT: 500, // Limit initial Firebase data load
            UPDATE_INTERVAL: 5000, // Update interval in ms
            CACHE_DURATION: 30000 // Cache duration for calculations
        };

        // Initialize Firebase with optimized settings
        var firebaseConfig = {
            apiKey: "AIzaSyBIf_5OwMDRKm35I0x3v5LbibYyrBrug9k",
            databaseURL: "https://customer-2-88220-default-rtdb.firebaseio.com/"
        };

        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        var database = firebase.database();

        // Global variables with initial values
        let chartDataCache = {
            labels: [],
            values: [],
            lastUpdated: 0
        };

        let calculationsCache = {
            daily: null,
            monthly: null,
            timestamp: 0
        };

        // Optimized Chart Initialization
        var ctx = document.getElementById('productionChart').getContext('2d');
        var productionChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: [],
                datasets: [{
                    label: 'Production Over Time',
                    data: [],
                    borderColor: 'rgba(75, 192, 192, 1)',
                    backgroundColor: 'rgba(75, 192, 192, 0.2)',
                    fill: true,
                    tension: 0.4,
                    pointRadius: 3,
                    pointHoverRadius: 8
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: {
                    duration: 500 // Faster animations
                },
                plugins: {
                    zoom: {
                        pan: {
                            enabled: true,
                            mode: 'xy',
                            speed: 8,
                            threshold: 10
                        },
                        zoom: {
                            wheel: {
                                enabled: true,
                                speed: 0.08
                            },
                            pinch: {
                                enabled: true
                            },
                            drag: {
                                enabled: false
                            },
                            mode: 'x'
                        }
                    }
                },
                scales: {
                    x: {
                        display: true,
                        title: {
                            display: true,
                            text: 'Date',
                            color: '#333',
                            font: {
                                size: 14,
                                weight: 'bold'
                            }
                        }
                    },
                    y: {
                        display: true,
                        title: {
                            display: true,
                            text: 'Production Count',
                            color: '#333',
                            font: {
                                size: 14,
                                weight: 'bold'
                            }
                        }
                    }
                }
            }
        });

        // Function to load initial data efficiently
        async function loadInitialData() {
            try {
                // Load limited recent data first (for fast display)
                const recentData = await loadRecentData();
                
                // Update UI immediately with recent data
                updateUIWithRecentData(recentData);
                
                // Load historical data in background
                setTimeout(loadHistoricalData, 1000);
                
                // Start real-time updates
                startRealTimeUpdates();
                
            } catch (error) {
                console.error("Error loading initial data:", error);
                showErrorMessage("Failed to load data. Please refresh.");
            }
        }

        // Load only recent data for fast display
        async function loadRecentData() {
            const snapshot = await database.ref('Sensor/readings')
                .orderByKey()
                .limitToLast(OPTIMIZATION_CONFIG.FIREBASE_LIMIT)
                .once('value');
            
            return snapshot.val() || {};
        }

        // Load historical data in background
        async function loadHistoricalData() {
            const sensorRef = database.ref('Sensor/readings');
            const snapshot = await sensorRef.once('value');
            const data = snapshot.val();
            
            if (data) {
                processAndCacheHistoricalData(data);
                updateChartWithCachedData();
                calculateAndCacheProductionValues();
            }
        }

        // Process and cache historical data efficiently
        function processAndCacheHistoricalData(data) {
            const timeLabels = [];
            const productionValues = [];
            const dataPoints = [];
            
            // Convert object to array and sort by timestamp
            Object.keys(data).forEach(key => {
                const item = data[key];
                if (item && item.timestamp && item.length !== undefined) {
                    dataPoints.push({
                        timestamp: item.timestamp * 1000,
                        length: parseFloat(item.length)
                    });
                }
            });
            
            // Sort by timestamp
            dataPoints.sort((a, b) => a.timestamp - b.timestamp);
            
            // Sample data if there are too many points
            const samplingRate = Math.max(1, Math.floor(dataPoints.length / OPTIMIZATION_CONFIG.CHART_DATA_POINTS));
            
            for (let i = 0; i < dataPoints.length; i += samplingRate) {
                const point = dataPoints[i];
                const date = new Date(point.timestamp);
                
                // Format date efficiently
                const formattedDate = `${date.getDate().toString().padStart(2, '0')}/${(date.getMonth()+1).toString().padStart(2, '0')}`;
                
                timeLabels.push(formattedDate);
                productionValues.push(point.length);
            }
            
            // Cache the processed data
            chartDataCache = {
                labels: timeLabels,
                values: productionValues,
                lastUpdated: Date.now()
            };
        }

        // Update chart with cached data
        function updateChartWithCachedData() {
            if (chartDataCache.labels.length > 0) {
                productionChart.data.labels = chartDataCache.labels;
                productionChart.data.datasets[0].data = chartDataCache.values;
                productionChart.update('none'); // 'none' prevents animation for faster update
            }
        }

        // Start real-time updates for latest data
        function startRealTimeUpdates() {
            // Listen only for new data (not all historical)
            var latestDataRef = database.ref('Sensor/readings')
                .orderByKey()
                .limitToLast(1);
            
            latestDataRef.on('child_added', (snapshot) => {
                const data = snapshot.val();
                if (data) {
                    updateRealTimeDisplay(data);
                    updateChartWithLatestPoint(data);
                }
            });

            // Update daily production counter
            database.ref('Sensor/perday').on('value', (snapshot) => {
                const data = snapshot.val();
                if (data && data.count !== undefined) {
                    const count = parseFloat(data.count).toFixed(1);
                    document.getElementById("last24HourProduction").innerText = count;
                }
            });
        }

        // Update real-time display values
        function updateRealTimeDisplay(data) {
            const latestValue = parseFloat(data.length).toFixed(2);
            const latestTimestamp = data.timestamp * 1000;
            const currentTime = Date.now();
            const minutesAgo = Math.floor((currentTime - latestTimestamp) / (1000 * 60));
            
            // Update displays
            document.getElementById("lastValueDisplay").innerText = latestValue;
            document.getElementById("lastUpdateDisplay").innerText = `${minutesAgo} minutes ago`;
            
            // Update machine status
            updateMachineStatus(latestValue, latestTimestamp);
            
            // Calculate and update machine speed
            updateMachineSpeed(latestValue, latestTimestamp);
        }

        // Update machine status efficiently
        function updateMachineStatus(currentLength, timestamp) {
            const minutesSinceUpdate = (Date.now() - timestamp) / (1000 * 60);
            let status;
            
            if (minutesSinceUpdate > 5) {
                status = "Offline";
            } else {
                const lastLength = localStorage.getItem('lastKnownLength');
                if (lastLength && parseFloat(lastLength).toFixed(2) !== currentLength) {
                    status = "Running";
                } else {
                    status = "Stopped";
                }
            }
            
            const statusElement = document.getElementById("machineStatus");
            statusElement.innerText = status;
            statusElement.className = status; // Apply CSS class
            
            // Store for next comparison
            localStorage.setItem('lastKnownLength', currentLength);
            localStorage.setItem('lastKnownTimestamp', timestamp);
        }

        // Update machine speed with optimized calculations
        let lastSpeedCalculation = {
            length: null,
            timestamp: null
        };

        function updateMachineSpeed(currentLength, timestamp) {
            if (lastSpeedCalculation.length && lastSpeedCalculation.timestamp) {
                const lengthDiff = currentLength - lastSpeedCalculation.length;
                const timeDiff = (timestamp - lastSpeedCalculation.timestamp) / 1000; // in seconds
                
                if (timeDiff > 0 && timeDiff < 300) { // Valid time window
                    const speed = (lengthDiff / timeDiff) * 60; // Convert to per minute
                    document.getElementById("machineSpeed").innerText = `${speed.toFixed(2)} M/min`;
                }
            }
            
            // Update for next calculation
            lastSpeedCalculation = {
                length: currentLength,
                timestamp: timestamp
            };
        }

        // Update chart with latest point
        function updateChartWithLatestPoint(data) {
            const timestamp = data.timestamp * 1000;
            const length = parseFloat(data.length);
            const date = new Date(timestamp);
            const formattedDate = `${date.getDate().toString().padStart(2, '0')}/${(date.getMonth()+1).toString().padStart(2, '0')}`;
            
            // Add to chart data (limit size for performance)
            productionChart.data.labels.push(formattedDate);
            productionChart.data.datasets[0].data.push(length);
            
            // Limit chart data points
            if (productionChart.data.labels.length > OPTIMIZATION_CONFIG.CHART_DATA_POINTS) {
                productionChart.data.labels.shift();
                productionChart.data.datasets[0].data.shift();
            }
            
            // Update chart efficiently
            productionChart.update('none');
            
            // Update production calculations periodically
            if (Date.now() - calculationsCache.timestamp > OPTIMIZATION_CONFIG.CACHE_DURATION) {
                calculateAndCacheProductionValues();
            }
        }

        // Calculate and cache production values
        function calculateAndCacheProductionValues() {
            const labels = productionChart.data.labels;
            const values = productionChart.data.datasets[0].data;
            
            if (labels.length < 2) return;
            
            // Calculate yesterday's production
            const yesterdayProduction = calculateYesterdayProduction(labels, values);
            document.getElementById("perDayProduction").innerText = yesterdayProduction.toFixed(2);
            
            // Calculate month's production
            const monthProduction = calculateMonthProduction(labels, values);
            document.getElementById("perMonthProduction").innerText = monthProduction.toFixed(2);
            
            // Cache results
            calculationsCache = {
                daily: yesterdayProduction,
                monthly: monthProduction,
                timestamp: Date.now()
            };
        }

        // Calculate yesterday's production efficiently
        function calculateYesterdayProduction(labels, values) {
            const today = new Date();
            const yesterday = new Date(today);
            yesterday.setDate(today.getDate() - 1);
            
            const yesterdayStr = `${yesterday.getDate().toString().padStart(2, '0')}/${(yesterday.getMonth()+1).toString().padStart(2, '0')}`;
            
            let yesterdayValues = [];
            
            for (let i = 0; i < labels.length; i++) {
                if (labels[i] === yesterdayStr) {
                    yesterdayValues.push(values[i]);
                }
            }
            
            if (yesterdayValues.length >= 2) {
                return yesterdayValues[yesterdayValues.length - 1] - yesterdayValues[0];
            }
            
            return 0;
        }

        // Calculate month's production efficiently
        function calculateMonthProduction(labels, values) {
            const currentMonth = (new Date().getMonth() + 1).toString().padStart(2, '0');
            let monthValues = [];
            
            for (let i = 0; i < labels.length; i++) {
                if (labels[i].endsWith(`/${currentMonth}`)) {
                    monthValues.push(values[i]);
                }
            }
            
            if (monthValues.length >= 2) {
                return monthValues[monthValues.length - 1] - monthValues[0];
            }
            
            return 0;
        }

        // Update UI with recent data (for fast initial display)
        function updateUIWithRecentData(data) {
            if (!data) return;
            
            const keys = Object.keys(data);
            if (keys.length > 0) {
                const latestKey = keys[keys.length - 1];
                const latestData = data[latestKey];
                
                if (latestData) {
                    document.getElementById("lastValueDisplay").innerText = parseFloat(latestData.length).toFixed(2);
                    
                    const minutesAgo = Math.floor((Date.now() - (latestData.timestamp * 1000)) / (1000 * 60));
                    document.getElementById("lastUpdateDisplay").innerText = `${minutesAgo} minutes ago`;
                }
            }
        }

        // Export to Excel function (optimized)
        function exportToExcel() {
            const wb = XLSX.utils.book_new();
            const labels = productionChart.data.labels;
            const values = productionChart.data.datasets[0].data;
            
            // Prepare daily sheet data
            const dailyData = [["Date", "Daily Production"]];
            const dailyMap = {};
            
            // Group by date
            for (let i = 0; i < labels.length; i++) {
                const date = labels[i];
                if (!dailyMap[date]) {
                    dailyMap[date] = {
                        first: values[i],
                        last: values[i]
                    };
                }
                dailyMap[date].last = values[i];
            }
            
            // Calculate daily production
            Object.keys(dailyMap).sort().forEach(date => {
                const production = dailyMap[date].last - dailyMap[date].first;
                dailyData.push([date, production]);
            });
            
            const dailySheet = XLSX.utils.aoa_to_sheet(dailyData);
            XLSX.utils.book_append_sheet(wb, dailySheet, "Daily Production");
            
            // Prepare monthly sheet data
            const monthlyData = [["Month", "Total Monthly Production"]];
            const monthNames = ["January", "February", "March", "April", "May", "June", 
                              "July", "August", "September", "October", "November", "December"];
            const monthlyMap = {};
            
            // Group by month
            for (let i = 0; i < labels.length; i++) {
                const monthIndex = parseInt(labels[i].split('/')[1]) - 1;
                if (!monthlyMap[monthIndex]) {
                    monthlyMap[monthIndex] = {
                        first: values[i],
                        last: values[i]
                    };
                }
                monthlyMap[monthIndex].last = values[i];
            }
            
            // Calculate monthly production
            monthNames.forEach((monthName, index) => {
                const production = monthlyMap[index] ? monthlyMap[index].last - monthlyMap[index].first : 0;
                monthlyData.push([monthName, production]);
            });
            
            const monthlySheet = XLSX.utils.aoa_to_sheet(monthlyData);
            XLSX.utils.book_append_sheet(wb, monthlySheet, "Monthly Production");
            
            XLSX.writeFile(wb, "ProductionReport.xlsx");
        }

        // Show error message
        function showErrorMessage(message) {
            const errorDiv = document.createElement('div');
            errorDiv.style.cssText = `
                position: fixed;
                top: 100px;
                right: 20px;
                background: #ff4444;
                color: white;
                padding: 15px;
                border-radius: 5px;
                z-index: 10000;
            `;
            errorDiv.textContent = message;
            document.body.appendChild(errorDiv);
            
            setTimeout(() => errorDiv.remove(), 5000);
        }

        // Go back function
        function goBack() {
            window.location.href = 'main.html';
        }

        // Initialize application
        document.addEventListener('DOMContentLoaded', function() {
            // Anonymous authentication
            firebase.auth().onAuthStateChanged((user) => {
                if (user) {
                    loadInitialData();
                } else {
                    firebase.auth().signInAnonymously().catch(console.error);
                }
            });

            // Auto-logout timer
            let logoutTimer;
            function resetTimer() {
                clearTimeout(logoutTimer);
                logoutTimer = setTimeout(() => {
                    localStorage.setItem("loggedIn", "false");
                    window.location.href = "index.html";
                }, 120000);
            }

            // Activity listeners
            ['mousemove', 'keypress', 'touchstart', 'click'].forEach(event => {
                document.addEventListener(event, resetTimer);
            });
            resetTimer();
        });

        // Disable right-click and dev tools
        document.addEventListener("contextmenu", e => e.preventDefault());
        document.addEventListener("keydown", e => {
            if (e.key === "F12" || (e.ctrlKey && e.shiftKey && e.key === "I") || 
                (e.ctrlKey && e.key === "U")) {
                e.preventDefault();
            }
        });
    </script>
</body>
</html>
